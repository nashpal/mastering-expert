/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include <numeric>

//==============================================================================
TestPluginAudioProcessorEditor::TestPluginAudioProcessorEditor (TestPluginAudioProcessor& p)
    :   AudioProcessorEditor (p),
        headroomBreachedLabel("", "Headroom: OK"),
        gainLabel ("", "Throughput level:"),
        dynamicRangeLabel("", "Dynamic Range: 0dB"),
        stereoCorrelationLabel("", "Correlation: 0"),
        stereoCorrelationConvolutionLabel("", "Convolution Correlation: 0"),
        gainSlider ("gain"),
        resetButton("Reset"),
        monoButton("Mono")
{
    
    addAndMakeVisible(&logo);
    addAndMakeVisible(vectorScope);
    
    addAndMakeVisible(headroomBreachedLabel);
    headroomBreachedLabel.setFont (Font (15.0f));
    
    addAndMakeVisible(resetButton);
    resetButton.addListener(this);
    
    addAndMakeVisible(monoButton);
    monoButton.addListener(this);
    
    addAndMakeVisible(dynamicRangeLabel);
    dynamicRangeLabel.setFont (Font (15.0f));
    
    addAndMakeVisible(stereoCorrelationLabel);
    stereoCorrelationLabel.setFont(Font(15.0f));
    
    addAndMakeVisible(stereoCorrelationConvolutionLabel);
    stereoCorrelationConvolutionLabel.setFont(Font(15.0f));
    
    
//    addAndMakeVisible (gainSlider);
//    gainSlider.setSliderStyle (Slider::Rotary);
//    gainSlider.addListener (this);
//    gainSlider.setRange (0.0, 1.0, 0.01);
    
    // add some labels for the sliders..
//    gainLabel.attachToComponent (&gainSlider, false);
//    gainLabel.setFont (Font (11.0f));
    
    // Make sure that before the constructor has finished, you've set the
    // editor's size to whatever you need it to be.
    setSize (1040, 410);
    
    getProcessor().addChangeListener(this);
    
    startTimer (100);
}

TestPluginAudioProcessorEditor::~TestPluginAudioProcessorEditor()
{
    getProcessor().removeChangeListener(this);
}

//==============================================================================
void TestPluginAudioProcessorEditor::paint (Graphics& g)
{
    
    g.fillAll (Colours::white);

//    g.setColour (Colours::black);
//    g.setFont (15.0f);
//    g.drawFittedText ("Hello World!", getLocalBounds(), Justification::centred, 1);
}

void TestPluginAudioProcessorEditor::resized()
{
    // This is generally where you'll want to lay out the positions of any
    // subcomponents in your editor..
    logo.setBounds(0, 0, 540, 200);
    vectorScope.setBounds(550, 0, 410, 410);
    
    headroomBreachedLabel.setBounds(5, 225, 200, 40);
    dynamicRangeLabel.setBounds(5, 270, 200, 40);
    stereoCorrelationLabel.setBounds(5, 315, 200, 40);
    stereoCorrelationConvolutionLabel.setBounds(5, 360, 200, 40);
    resetButton.setBounds(5, 210, 50, 20);
    monoButton.setBounds(60, 210, 50, 20);
//    gainSlider.setBoundsRelative(0.05, 0.85, 0.1, 0.1);
    
}

AudioProcessorParameter* TestPluginAudioProcessorEditor::getParameterFromSlider (const Slider* slider) const
{
    if (slider == &gainSlider)
        return getProcessor().gain;

    
    return nullptr;
}

void TestPluginAudioProcessorEditor::buttonClicked(juce::Button * button)
{
    
    if (button == &resetButton)
    {
        this->reset();
        return;
    }
    
    if(button == &monoButton)
    {
        monoButton.setToggleState(!monoButton.getToggleState(), dontSendNotification);
        
        getProcessor().mono = monoButton.getToggleState();
    }
    
}

// This is our Slider::Listener callback, when the user drags a slider.
void TestPluginAudioProcessorEditor::sliderValueChanged (Slider* slider)
{
    if (AudioProcessorParameter* param = getParameterFromSlider (slider))
    {
        // It's vital to use setValueNotifyingHost to change any parameters that are automatable
        // by the host, rather than just modifying them directly, otherwise the host won't know
        // that they've changed.
        param->setValueNotifyingHost ((float) slider->getValue());
    }
}

void TestPluginAudioProcessorEditor::sliderDragStarted (Slider* slider)
{
    if (AudioProcessorParameter* param = getParameterFromSlider (slider))
    {
        param->beginChangeGesture();
    }
}

void TestPluginAudioProcessorEditor::sliderDragEnded (Slider* slider)
{
    if (AudioProcessorParameter* param = getParameterFromSlider (slider))
    {
        param->endChangeGesture();
    }
}

void TestPluginAudioProcessorEditor::timerCallback()
{
    TestPluginAudioProcessor& processor = getProcessor();
    
    if (processor.lastPosInfo.isPlaying)
    {
        logo.setFFTBins(processor.logoFFTBins);
        
        gainSlider.setValue (processor.gain->getValue(), dontSendNotification);
        
        logo.repaint();
        
        if (processor.headroomBreached)
        {
            headroomBreachedLabel.setText("Headroom: Breached", dontSendNotification);
        } else
        {
            headroomBreachedLabel.setText("Headroom: OK", dontSendNotification);
        }
        
        vectorScope.setCurrentPointArray(processor.vectorScopePoints);
        
        vectorScope.repaint();
        
    } else
    {
        // Reset the logo
        logo.setFFTBins({ 10, 20, 30, 40, 40, 30, 20, 10 });
        
        logo.repaint();
    }
}

void TestPluginAudioProcessorEditor::changeListenerCallback(juce::ChangeBroadcaster *source)
{
    // We have been notified to check the dynamicRange array.
    TestPluginAudioProcessor& processor = static_cast<TestPluginAudioProcessor&>(*source);
    
    // Get the average of the dynamicRange, note this is still being changed by the audio thread,
    // but this is only a heuristic method anyway.
    float averageDynamicRange = std::accumulate(processor.dynamicRange.begin(), processor.dynamicRange.end(), 0.0) / 100.;
    
    float averageStereoCorrelation = std::accumulate(processor.stereoCorrelation.begin(), processor.stereoCorrelation.end(), 0.0) / 100.;
    
    float averageStereoConvolutionCorrelation = std::accumulate(processor.stereoCorrelationConvolution.begin(), processor.stereoCorrelationConvolution.end(), 0.0) / 100.;
    
    dynamicRangeLabel.setText("Dynamic Range: " + String(averageDynamicRange), dontSendNotification);
    stereoCorrelationLabel.setText("Correlation: " + String(averageStereoCorrelation), dontSendNotification);
    stereoCorrelationConvolutionLabel.setText("Convolution Correlation: " + String(averageStereoConvolutionCorrelation), dontSendNotification);
}

void TestPluginAudioProcessorEditor::reset()
{
    TestPluginAudioProcessor& processor = getProcessor();
    
    processor.headroomBreached = false;
}