/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include <numeric>

//==============================================================================
TestPluginAudioProcessorEditor::TestPluginAudioProcessorEditor (TestPluginAudioProcessor& p)
    :   AudioProcessorEditor (p),
        vectorScope(VectorScope::Mode::LISSAJOUS),
        headroomBreachedLabel("", "Headroom: OK"),
        dynamicRangeLabel("", "Dynamic Range: 0dB"),
        stereoCorrelationLabel("", "Stereo Correlation: 0"),
        resetButton("Reset"),
        monoButton("Mono"),
        leftLevel("","",""),
        rightLevel("-inf", "-6dB", "0db"),
        dynamicRangeLeftLevel("", "", ""),
        dynamicRangeRightLevel("0db", "10dB", "20db"),
        stereoCorrelationLevel("-1", "0", "+1"),
        bassSpaceLabel("", "Bass Space: soon!"),
        hyperLink("Get it mastered at Mastering The Mix", URL ("http://www.masteringthemix.com"))

{
    
    
    addAndMakeVisible(&logo);
    
    vectorScope.radius = 75;
    addChildComponent(vectorScope);
    
    addChildComponent(oscilloScope);
    
    headroomBreachedLabel.setJustificationType(juce::Justification::left);
    headroomBreachedLabel.setFont (Font (15.0f));
    addChildComponent(headroomBreachedLabel);
    
    lufsMomentaryLoudnessLabel.setJustificationType(juce::Justification::left);
    lufsMomentaryLoudnessLabel.setFont (Font (15.0f));
    addChildComponent(lufsMomentaryLoudnessLabel);
                  
    lufsShortTermLoudnessLabel.setJustificationType(juce::Justification::left);
    lufsShortTermLoudnessLabel.setFont (Font (15.0f));
    addChildComponent(lufsShortTermLoudnessLabel);
    
    rmsLabel.setJustificationType(juce::Justification::left);
    rmsLabel.setFont (Font (15.0f));
    addChildComponent(rmsLabel);
    
    peakLabel.setJustificationType(juce::Justification::left);
    peakLabel.setFont (Font (15.0f));
    addChildComponent(peakLabel);
    
    addAndMakeVisible(homeButton);
    homeButton.addListener(this);
    homeButton.setButtonText("Home");
    
    addAndMakeVisible(headroomButton);
    headroomButton.addListener(this);
    headroomButton.setButtonText("Heaadroom");
    
    addAndMakeVisible(dynamicRangeButton);
    dynamicRangeButton.addListener(this);
    dynamicRangeButton.setButtonText("Dynamic Range");
    
    addAndMakeVisible(stereoButton);
    stereoButton.addListener(this);
    stereoButton.setButtonText("Stereo");
    
    addAndMakeVisible(bassSpaceButton);
    bassSpaceButton.addListener(this);
    bassSpaceButton.setButtonText("Bass Space");
    
    resetButton.addListener(this);
    addChildComponent(resetButton);

    monoButton.addListener(this);
    addChildComponent(monoButton);
    
    dynamicRangeLabel.setJustificationType(juce::Justification::left);
    dynamicRangeLabel.setFont (Font (15.0f));
    addChildComponent(dynamicRangeLabel);
    
    stereoCorrelationLabel.setJustificationType(juce::Justification::left);
    stereoCorrelationLabel.setFont(Font(15.0f));
    addChildComponent(stereoCorrelationLabel);
    
    bassSpaceLabel.setJustificationType(juce::Justification::left);
    bassSpaceLabel.setFont(Font(15.0f));
    addChildComponent(bassSpaceLabel);

    hyperLink.setTooltip(String("www.masteringthemix.com"));
    hyperLink.setFont(Font(15.0f), false, juce::Justification::left);
    addChildComponent(hyperLink);
    
    leftLevel.barCount = 20;
    leftLevel.barWidth = 16;
    leftLevel.minValue = 0;
    leftLevel.maxValue = 1;
    leftLevel.overBar = 11;
    leftLevel.step = 2;
    leftLevel.overColour = Colours::red;
    leftLevel.underColour = Colours::green;
    leftLevel.barColour = Colours::black;
    leftLevel.meterType = MeterType::NORMAL;
    addChildComponent(leftLevel);
    
    rightLevel.barCount = 20;
    rightLevel.barWidth = 16;
    rightLevel.minValue = 0;
    rightLevel.maxValue = 1;
    rightLevel.overBar = 11;
    rightLevel.step = 2;
    rightLevel.overColour = Colours::red;
    rightLevel.underColour = Colours::green;
    rightLevel.barColour = Colours::black;
    rightLevel.meterType = MeterType::NORMAL;
    addChildComponent(rightLevel);
    
    
    dynamicRangeLeftLevel.barCount = 20;
    dynamicRangeLeftLevel.barWidth = 16;
    dynamicRangeLeftLevel.minValue = 0;
    dynamicRangeLeftLevel.maxValue = 1;
    dynamicRangeLeftLevel.overBar = 11;
    dynamicRangeLeftLevel.step = 2;
    dynamicRangeLeftLevel.overColour = Colours::red;
    dynamicRangeLeftLevel.underColour = Colours::green;
    dynamicRangeLeftLevel.barColour = Colours::black;
    dynamicRangeLeftLevel.meterType = MeterType::DYNAMICRANGE;
    addChildComponent(dynamicRangeLeftLevel);
    
    dynamicRangeRightLevel.barCount = 20;
    dynamicRangeRightLevel.barWidth = 16;
    dynamicRangeRightLevel.minValue = 0;
    dynamicRangeRightLevel.maxValue = 1;
    dynamicRangeRightLevel.overBar = 11;
    dynamicRangeRightLevel.step = 2;
    dynamicRangeRightLevel.overColour = Colours::red;
    dynamicRangeRightLevel.underColour = Colours::green;
    dynamicRangeRightLevel.barColour = Colours::black;
    dynamicRangeRightLevel.meterType = MeterType::DYNAMICRANGE;
    addChildComponent(dynamicRangeRightLevel);
    
    
    stereoCorrelationLevel.barCount = 20;
    stereoCorrelationLevel.barWidth = 16;
    stereoCorrelationLevel.minValue = 0;
    stereoCorrelationLevel.maxValue = 2;
    stereoCorrelationLevel.overBar = 10;
    stereoCorrelationLevel.step = 2;
    stereoCorrelationLevel.overColour = Colours::red;
    stereoCorrelationLevel.underColour = Colours::green;
    stereoCorrelationLevel.barColour = Colours::black;
    stereoCorrelationLevel.meterType = MeterType::CORRRELATION;
    addChildComponent(stereoCorrelationLevel);
    
    freq1Label.setJustificationType(juce::Justification::left);
    freq1Label.setFont(Font(10.0f));
    addChildComponent(freq1Label);
    
    freq2Label.setJustificationType(juce::Justification::left);
    freq2Label.setFont(Font(10.0f));
    addChildComponent(freq2Label);
    
    freq3Label.setJustificationType(juce::Justification::left);
    freq3Label.setFont(Font(10.0f));
    addChildComponent(freq3Label);
    
    freq4Label.setJustificationType(juce::Justification::left);
    freq4Label.setFont(Font(10.0f));
    addChildComponent(freq4Label);
    
    blockSizeLabel.setJustificationType(juce::Justification::left);
    blockSizeLabel.setFont(Font(10.0f));
    addChildComponent(blockSizeLabel);
    
    // Make sure that before the constructor has finished, you've set the
    // editor's size to whatever you need it to be.
    setSize (745, 510);
    
    getProcessor().addActionListener(this);
    
    // Fill this with effectively silence.
    lufsShortTermLoudness.fill(-140);
    
    startTimer (40);
    
    mode = UIConstants::Mode::HOME;
}

TestPluginAudioProcessorEditor::~TestPluginAudioProcessorEditor()
{
    getProcessor().removeActionListener(this);
    
    stopTimer();
}

//==============================================================================
void TestPluginAudioProcessorEditor::paint (Graphics& g)
{
    
    g.fillAll (Colours::white);

}

void TestPluginAudioProcessorEditor::resized()
{
    // This is generally where you'll want to lay out the positions of any
    // subcomponents in your editor..
    
    logo.setBounds(0, 0, 540, 200);
    
    vectorScope.setBounds(550, 0, 192, 286);
    
    oscilloScope.setBounds(550, 0, 192, 286);
    
    leftLevel.setBounds(5, 150, 16, 100);
    rightLevel.setBounds(23, 150, 50, 100);
    headroomBreachedLabel.setBounds(5, 240, 200, 40);
    lufsMomentaryLoudnessLabel.setBounds(5, 260, 200, 40);
    lufsShortTermLoudnessLabel.setBounds(5, 280, 200, 40);
    peakLabel.setBounds(5, 300, 200, 40);
    rmsLabel.setBounds(5, 320, 200, 40);
    
    dynamicRangeLabel.setBounds(205, 350, 200, 40);
    dynamicRangeLeftLevel.setBounds(205, 250, 50, 100);
    dynamicRangeRightLevel.setBounds(255, 250, 50, 100);

    stereoCorrelationLabel.setBounds(405, 350, 200, 40);
    stereoCorrelationLevel.setBounds(405, 250, 50, 100);
    
    bassSpaceLabel.setBounds(605, 350, 200, 40);
    
    freq1Label.setBounds(605, 230, 100, 25);
    freq2Label.setBounds(605, 260, 100, 25);
    freq3Label.setBounds(605, 290, 100, 25);
    freq4Label.setBounds(605, 320, 100, 25);
    blockSizeLabel.setBounds(605, 200, 100, 25);
    
    homeButton.setBounds(4, 440, 50, 20);
    headroomButton.setBounds(5, 400, 100, 20);
    dynamicRangeButton.setBounds(205, 400, 150, 20);
    stereoButton.setBounds(405, 400, 50, 20);
    bassSpaceButton.setBounds(605, 400, 150, 20);
    
    resetButton.setBounds(60, 440, 50, 20);
    monoButton.setBounds(60, 440, 50, 20);
    
    hyperLink.setBounds(0, 470, 300, 40);
}



void TestPluginAudioProcessorEditor::buttonClicked(juce::Button * button)
{
    
    if (button == &resetButton)
    {
        this->reset();
        return;
    }
    
    if(button == &monoButton)
    {
        monoButton.setToggleState(!monoButton.getToggleState(), dontSendNotification);
        
        getProcessor().mono = monoButton.getToggleState();
    }
    
    if (button == &headroomButton)
    {
        this->hideComponents();
        this->showComponents();
        
        leftLevel.setVisible(true);
        rightLevel.setVisible(true);
        headroomBreachedLabel.setVisible(true);
        lufsMomentaryLoudnessLabel.setVisible(true);
        lufsShortTermLoudnessLabel.setVisible(true);
        peakLabel.setVisible(true);
        rmsLabel.setVisible(true);
        
        mode = UIConstants::Mode::HEADROOM;
        
        getProcessor().mode = mode;
    }
    
    if (button == &dynamicRangeButton)
    {
        this->hideComponents();
        this->showComponents();
        
        dynamicRangeLeftLevel.setVisible(true);
        dynamicRangeRightLevel.setVisible(true);
        dynamicRangeLabel.setVisible(true);
        oscilloScope.setVisible(true);
        
        mode = UIConstants::Mode::DYNAMIC_RANGE;
        
        getProcessor().mode = mode;

    }
    
    if(button == &stereoButton)
    {
        this->hideComponents();
        this->showComponents();
        
        monoButton.setVisible(true);
        stereoCorrelationLevel.setVisible(true);
        vectorScope.setVisible(true);
        
        mode = UIConstants::Mode::STEREO;
        
        getProcessor().mode = mode;

    }
    
    if(button == &bassSpaceButton)
    {
        this->hideComponents();
        this->showComponents();
        
        freq1Label.setVisible(true);
        freq2Label.setVisible(true);
        freq3Label.setVisible(true);
        freq4Label.setVisible(true);
        
        mode = UIConstants::Mode::BASS_SPACE;
        
        getProcessor().mode = mode;

    }
    
    if(button == &homeButton)
    {
        this->hideComponents();
        this->showComponents();
        
        logo.setVisible(true);
        
        mode = UIConstants::Mode::HOME;
        
        getProcessor().mode = mode;
    }
    
}


void TestPluginAudioProcessorEditor::timerCallback()
{
    TestPluginAudioProcessor& processor = getProcessor();
    
    if (processor.lastPosInfo.isPlaying)
    {
        scopeFadeoutCount = 0;
        
        if (mode == UIConstants::Mode::HOME)
        {
            logo.setFFTBins(processor.logoFFTBins);
            logo.repaint();
        }
        
        if (mode == UIConstants::Mode::HEADROOM)
        {
            leftLevel.levelData = processor.leftRMS; //processor.leftRMS;
            rightLevel.levelData = processor.rightRMS; //rightRMS;
            leftLevel.repaint();
            rightLevel.repaint();
            
            if (processor.headroomBreached)
            {
                headroomBreachedLabel.setText("Headroom: Breached", dontSendNotification);
            }
            
            peakLabel.setText("Peak L: " + String(20 * log10f(processor.leftPeak), 1) + "dB  R: " + String(20 * log10f(processor.rightPeak), 1) + "dB", dontSendNotification);
        }
        
        if (mode == UIConstants::Mode::STEREO)
        {
            stereoCorrelationLevel.levelData = processor.stereoCorrelation + 1;
            stereoCorrelationLevel.repaint();
            stereoCorrelationLabel.setText("Stereo Correlation: " + String(processor.stereoCorrelation, 2), dontSendNotification);
            
            vectorScope.setCurrentPointArray(processor.scopePoints);
            vectorScope.repaint();
        }
        
        if (mode == UIConstants::Mode::DYNAMIC_RANGE)
        {
            dynamicRangeLeftPeaks[dynamicRangeBlockCount % 30] = processor.leftBlockMax;
            dynamicRangeRightPeaks[dynamicRangeBlockCount % 30] = processor.rightBlockMax;
            
            dynamicRangeLeftRMS[dynamicRangeBlockCount % 30] = processor.leftRMS;
            dynamicRangeRightRMS[dynamicRangeBlockCount % 30] = processor.rightRMS;
            
            float leftPeakAverage = std::accumulate(dynamicRangeLeftPeaks.begin(), dynamicRangeLeftPeaks.end(), 0.0) / 30.0;
            float rightPeakAverage = std::accumulate(dynamicRangeRightPeaks.begin(), dynamicRangeRightPeaks.end(), 0.0) / 30.0;
            
            float dynamicRangeLeftRMSAverage = std::accumulate(dynamicRangeLeftRMS.begin(), dynamicRangeLeftRMS.end(), 0.0) / 30.0;
            float dynamicRangeRightRMSAverage = std::accumulate(dynamicRangeRightRMS.begin(), dynamicRangeRightRMS.end(), 0.0) / 30.0;
            
            dynamicRangeLeftLevel.levelData = dynamicRangeLeftRMSAverage / leftPeakAverage;
            dynamicRangeLeftLevel.repaint();
            
            dynamicRangeRightLevel.levelData = dynamicRangeRightRMSAverage / rightPeakAverage ;
            dynamicRangeRightLevel.repaint();
            
            dynamicRangeLabel.setText("Dynamic Range L:" + String(-20 * log10f(dynamicRangeLeftRMSAverage / leftPeakAverage), 1) + "dB" + " R:" + String(-20 * log10f(dynamicRangeRightRMSAverage / rightPeakAverage), 1) + "dB", dontSendNotification);
            
            oscilloScope.setCurrentPointArray(processor.scopePoints);
            oscilloScope.repaint();
            
            dynamicRangeBlockCount++;
        }

        
    } else
    {
        
        if (mode == UIConstants::Mode::DYNAMIC_RANGE)
        {
            if (scopeFadeoutCount < UIConstants::NUMBER_SCOPE_BUFFERS)
            {
                // Seems like we have just stopped playing so fade out scope.
                oscilloScope.setCurrentPointArray(std::array<juce::Point<float>, UIConstants::NUMBER_SCOPE_POINTS>{ juce::Point<float>(0,0) });
                scopeFadeoutCount++;

                oscilloScope.repaint();
            }
        }
        
        if (mode == UIConstants::Mode::STEREO)
        {
            if (scopeFadeoutCount < UIConstants::NUMBER_SCOPE_BUFFERS)
            {
                // Seems like we have just stopped playing so fade out vectorscope.
                vectorScope.setCurrentPointArray(std::array<juce::Point<float>, UIConstants::NUMBER_SCOPE_POINTS>{ juce::Point<float>(0,0) });
                scopeFadeoutCount++;
                
                vectorScope.repaint();
            }
        }
        
        
        
        if (mode == UIConstants::Mode::HOME)
        {
            // Reset the logo
            logo.setFFTBins({ 10, 20, 30, 40, 40, 30, 20, 10 });
            logo.repaint();
        }
        
        lufsBlockCount = 0;
        dynamicRangeBlockCount = 0;
    }
}

void TestPluginAudioProcessorEditor::actionListenerCallback(const String& message)
{
    
    TestPluginAudioProcessor& processor = getProcessor();
    
    if (message == UIConstants::LUFS_MESSAGE)
    {
        float momentaryLoudnessEnergySum = 0;
        float shortTermLoudnessEnergySum = 0;
        
        // Store this new 100ms block energy value, we have 4 x 100ms blocks here to give a 400ms average.
        lufsMomentaryLoudnessEnergyBlocks[lufsBlockCount % 4] = processor.lufsMomentaryLoudnessBlockEnergySafe;
        
        // Store this new 100ms block energy value, we have 30 x 100ms blocks here to give a 3s average.
        lufsShortTermLoudnessEnergyBlocks[lufsBlockCount % 30] = processor.lufsMomentaryLoudnessBlockEnergySafe;
        
        // Now report the 400ms averaged Momentary Loudness level by summing the four blocks.
        momentaryLoudnessEnergySum = std::accumulate(lufsMomentaryLoudnessEnergyBlocks.begin(), lufsMomentaryLoudnessEnergyBlocks.end(), 0.0);
        float lufs = -0.691 + (10 * log10f((1.f / processor.lufsMomentaryLoudnessSampleCount) * momentaryLoudnessEnergySum));
        lufsMomentaryLoudnessLabel.setText("Momentary LUFS: " + String(lufs, 1), dontSendNotification);

        
        // Now report the 3s averaged Short Term Loudness level by summing the 30 blocks.
        shortTermLoudnessEnergySum = std::accumulate(lufsShortTermLoudnessEnergyBlocks.begin(), lufsShortTermLoudnessEnergyBlocks.end(), 0.0);
        lufs = -0.691 + (10 * log10f((1.f / processor.lufsShortTermLoudnessSampleCount) * shortTermLoudnessEnergySum));
        lufsShortTermLoudnessLabel.setText("Short Term LUFS: " + String(lufs, 1), dontSendNotification);
        
        /*
        
         Now to calculate loudness range.
         
         https://tech.ebu.ch/docs/tech/tech3342.pdf
         
         */
        
        /*
        // Get vector of short term loudness levels.
        lufsShortTermLoudness[lufsBlockCount % 30] = lufs;
        
        // Apply absolute threshold gating. Remove very quiet parts!
        std::copy_if(lufsShortTermLoudness.begin(),
                     lufsShortTermLoudness.end(),
                     std::back_inserter(lufsAbsoluteGated),
                     [this](float val) { return val >= LUFS_ABSOLUTE_THRESHOLD;} );
        
        // Now lufsGated has levels above absolute threshold.
        int n = lufsAbsoluteGated.size();
        
        // The 10% and 95% values.
        float lowPercentile = 0;
        float highPercentile = 0;
        
        // Could have been all silent.
        if (n > 0)
        {
            // Remove log to get power back.
            std::transform(lufsAbsoluteGated.begin(),
                           lufsAbsoluteGated.end(),
                           std::back_inserter(lufsLogRemoved) ,
                           [](float val){ return powf(10, val / 10.f); });
            
            // Get the mean power.
            float meanPower = std::accumulate(lufsLogRemoved.begin(), lufsLogRemoved.end(), 0.0) / n;
            float meanLufs = 10 * log10f(meanPower);
            
            // Now we can get loudness levels above relative threshold.
            std::copy_if(lufsAbsoluteGated.begin(),
                         lufsAbsoluteGated.end(),
                         std::back_inserter(lufsRelativeGated),
                         [&meanLufs, this](float val) { return val >= meanLufs + LUFS_RELATIVE_THRESHOLD; });
            
            n = lufsRelativeGated.size();
            
            // Sort these levels that are now above the relative threshold
            std::sort(lufsRelativeGated.begin(), lufsRelativeGated.end());
            
            // Need to get the 10% value and the 90% value
            lowPercentile = lufsRelativeGated[roundf((n - 1) * LUFS_LOWER_PERCENTILE / 100 + 1)];
            highPercentile = lufsRelativeGated[roundf((n - 1) * LUFS_UPPER_PERCENTILE / 100 + 1)];
            
        }
        
        dynamicRangeLabel.setText("Dynamic Range: " + String(highPercentile - lowPercentile, 1) + "LUFS", dontSendNotification);
        
        lufsAbsoluteGated.clear();
        lufsRelativeGated.clear();
        lufsLogRemoved.clear();

         */
        
        lufsBlockCount++;
    }
    
    if (message == UIConstants::DYNAMIC_RANGE_MESSAGE)
    {
        // We have been notified to check the dynamicRange array.

        // Get the average of the dynamicRange, note this is still being changed by the audio thread,
        // but this is only a heuristic method anyway.
        float averageDynamicRange = std::accumulate(processor.dynamicRangeAvg.begin(), processor.dynamicRangeAvg.end(), 0.0) / 10;
        float maxDynamicRange = *std::max_element(processor.dynamicRangeMax.begin(), processor.dynamicRangeMax.end());

        dynamicRangeLeftLevel.levelData = 20 * log10f(maxDynamicRange / averageDynamicRange);
        dynamicRangeLeftLevel.repaint();

        dynamicRangeLabel.setText("Dynamic Range: " + String(20 * log10f(maxDynamicRange / averageDynamicRange), 2) + "dB", dontSendNotification);
    }
    
    if (message == UIConstants::BASS_SPACE_MESSAGE)
    {
        float averageFilteredRMSdB = 20 * log10f(std::accumulate(processor.leftRMSFilteredAverage.begin(), processor.leftRMSFilteredAverage.end(), 0.0) / 100);
        float averageBinLeveldB = std::accumulate(processor.binAmplitudes[0].begin(), processor.binAmplitudes[0].end(), 0.0) / 100;
        freq1Label.setText("Freq: " + String(processor.binFrequencies[0]) + "Hz | Amp: " + String(averageFilteredRMSdB / averageBinLeveldB) , dontSendNotification);
        
        averageBinLeveldB = std::accumulate(processor.binAmplitudes[1].begin(), processor.binAmplitudes[1].end(), 0.0) / 100;
        freq2Label.setText("Freq: " + String(processor.binFrequencies[1]) + "Hz | Amp: " + String(averageFilteredRMSdB / averageBinLeveldB), dontSendNotification);
        
        averageBinLeveldB = std::accumulate(processor.binAmplitudes[2].begin(), processor.binAmplitudes[2].end(), 0.0) / 100;
        freq3Label.setText("Freq: " + String(processor.binFrequencies[2]) + "Hz | Amp: " + String(averageFilteredRMSdB / averageBinLeveldB), dontSendNotification);
        
        averageBinLeveldB = std::accumulate(processor.binAmplitudes[3].begin(), processor.binAmplitudes[3].end(), 0.0) / 100;
        freq4Label.setText("Freq: " + String(processor.binFrequencies[3]) + "Hz | Amp: " + String(averageFilteredRMSdB / averageBinLeveldB), dontSendNotification);
        
        blockSizeLabel.setText("Blocksize: " + String(processor.blockSize), dontSendNotification);
    }
    

    
}

void TestPluginAudioProcessorEditor::reset()
{
    TestPluginAudioProcessor& processor = getProcessor();
    
    processor.headroomBreached = false;
    processor.leftPeak = 0.001;
    processor.rightPeak = 0.001;
    
    headroomBreachedLabel.setText("Headroom: OK", dontSendNotification);
}

void TestPluginAudioProcessorEditor::hideComponents()
{
    int numChildren = this->getNumChildComponents();
    
    for (int i = 0; i < numChildren; i++) {
        this->getChildComponent(i)->setVisible(false);
    }
}

void TestPluginAudioProcessorEditor::showComponents()
{
    headroomButton.setVisible(true);
    dynamicRangeButton.setVisible(true);
    stereoButton.setVisible(true);
    bassSpaceButton.setVisible(true);
    homeButton.setVisible(true);
    hyperLink.setVisible(true);
    resetButton.setVisible(true);
}